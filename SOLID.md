# SOLID
객체지향 설계(OOD)의 5원칙

+ SRP (단일 책임 원칙)
+ OCP (개방 폐쇄 원칙)
+ LSP (리스코프 치환 법칙)
+ ISP (인터페이스 분리 법칙)
+ DIP (의존 역전 법칙)

+ 좋은 소프트웨어 설계를 위해 결합도는 낮추고 응집도는 높이는 것이 바람직함.
  - 결합도 : 모듈(클래스) 간의 상호 의존 정도   
    결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객채의 재사용이나 수정, 유지보수가 용이함
  + 응집도 : 하나의 모듈 내부에 존재하는 구송 요소들의 기능적 관련성   
    응집도가 높을수록 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이함



## SRP - 단일 책임 원칙
  어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. - 로버트 C. 마틴

+ 속성이 SRP 원칙을 위배한 경우
  + 서브 클래스 전체에 공통적으로 필요하지 않는 속성을 슈퍼 클래스 속성에 작성한 경우   
  + 하나의 속성이 여러 의미를 갖는 경우

```

class 사람 {
  String 군번;
  String 이름;
  ...
}

사람 로미오 = new 사람();
사람 줄리엣 = new 사람();

줄리엣.군번 = "12354"; // ?

```
남성만 군번 속성을 가질 수 있도록 코드를 작성하고 싶었으나,   
위와 같이 코드를 작성하면 여성이 군번 속성을 읽어오거나 값을 할당하는것을 제제할 방법이 없다.   
위 소스를 리팩토링하면 다음과 같다.


```

class 사람 {
  String 이름;
  ...
}

class 남성 extends 사람 {
  String 군번;
}

class 여성 extends 사람 {
  ...
}

사람 로미오 = new 남성();
사람 줄리엣 = new 여성();

줄리엣.군번 = "12354"; // 군번 속성을 읽어오거나 값을 할당할 수 없다.

```


+ 메서드가 SRP 원칙을 위배한 경우
  + 소변보다() 메서드가 수컷과 암컷의 행위 모두를 구현하려고 하기 때문에 SRP 원칙을 위배한다.
  + 메서드가 SRP 원칙을 위배할 때 나타나는 대표적인 경우가 분기처리를 위한 if문이다.

```

class 강아지 {
  final static Boolean 수컷 = true;
  final static Boolean 암컷 = false;
  Boolean 성별;
  
  void 소변보다() {
    if(this.성별 == 수컷) {
      // ...
    } else {
      // ...
    }
  }
}

```
    
위 메서드를 SRP 원칙을 적용해 리팩토링 하면 다음과 같다.

```

abstract class 강아지 {
  abstract void 소변보다()
}

class 수컷강아지 extends 강아지 {
  void 소변보다() {
    // ...
  }
}

class 암컷강아지 extends 강아지 {
  void 소변보다() {
    // ...
  }
}

```
  
  
## OCP - 개방 폐쇄 원칙
소프트웨어 엔티티(클래스, 모듈, 함수 등)은 확장에 대해서는 열려 있어야 하지만, 변경에 대해서는 닫혀 있어야 한다. - 로버트 C.마틴

운전자가 수동 조작 차량을 보유하고 있었는데, 이후 자동 조작 차량으로 차량을 변경하게 되었다.
현실 세계에서라면 습관에 변화가 생기는게 불가피하지만 객체 지향 세계에서는 이를 방지할 수 있다.

+ 아래와 같이 코드를 작성하면 수동 조작 차량을 보유했을 때와 자동 조작 차량을 보유했을 때 일일이 메서드를 변경해야 한다.
```

class 마티즈 {
  void 수동 기어 조작() {
    ...
  }
}

마티즈 운전자 = new 마티즈();

// 또는

class 쏘나타 {
  void 자동 기어 조작() {
    ...
  }
}

쏘나타 운전자 = new 쏘나타();

``` 
  
+ 위 코드를 리팩토링하여 작성하면 다음과 같다.

```

interface 자동차 {
  abstract void 창문개방();
  abstract void 기어조작();
}

class 마티즈 implements 자동차 {
  void 창문개방() {
    ...
  }
  
  void 기어조작() {
    ...
  }
}

class 쏘나타 implements 자동차 {
  void 창문개방() {
    ...
  }
  
  void 기어조작() {
    ...
  }
}

자동차 운전자 = new 마티즈();
자동차 운전자 = new 쏘나타();

```
  
  
