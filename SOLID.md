# SOLID
객체지향 설계(OOD)의 5원칙

+ SRP (단일 책임 원칙)
+ OCP (개방 폐쇄 원칙)
+ LSP (리스코프 치환 법칙)
+ ISP (인터페이스 분리 법칙)
+ DIP (의존 역전 법칙)

+ 좋은 소프트웨어 설계를 위해 결합도는 낮추고 응집도는 높이는 것이 바람직함.
  - 결합도 : 모듈(클래스) 간의 상호 의존 정도   
    결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객채의 재사용이나 수정, 유지보수가 용이함
  + 응집도 : 하나의 모듈 내부에 존재하는 구송 요소들의 기능적 관련성   
    응집도가 높을수록 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이함



## SRP - 단일 책임 원칙
  어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. - 로버트 C. 마틴

+ 속성이 SRP 원칙을 위배한 경우
  + 서브 클래스 전체에 공통적으로 필요하지 않는 속성을 슈퍼 클래스 속성에 작성한 경우   
  + 하나의 속성이 여러 의미를 갖는 경우

```

class 사람 {
  String 군번;
  String 이름;
  ...
}

사람 로미오 = new 사람();
사람 줄리엣 = new 사람();

줄리엣.군번 = "12354"; // ?

```
남성만 군번 속성을 가질 수 있도록 코드를 작성하고 싶었으나,   
위와 같이 코드를 작성하면 여성이 군번 속성을 읽어오거나 값을 할당하는것을 제제할 방법이 없다.   
위 소스를 리팩토링하면 다음과 같다.


```

class 사람 {
  String 이름;
  ...
}

class 남성 extends 사람 {
  String 군번;
}

class 여성 extends 사람 {
  ...
}

사람 로미오 = new 남성();
사람 줄리엣 = new 여성();

줄리엣.군번 = "12354"; // 군번 속성을 읽어오거나 값을 할당할 수 없다.

```


+ 메서드가 SRP 원칙을 위배한 경우
  + 소변보다() 메서드가 수컷과 암컷의 행위 모두를 구현하려고 하기 때문에 SRP 원칙을 위배한다.
  + 메서드가 SRP 원칙을 위배할 때 나타나는 대표적인 경우가 분기처리를 위한 if문이다.

```

class 강아지 {
  final static Boolean 수컷 = true;
  final static Boolean 암컷 = false;
  Boolean 성별;
  
  void 소변보다() {
    if(this.성별 == 수컷) {
      // ...
    } else {
      // ...
    }
  }
}

```
    
위 메서드를 SRP 원칙을 적용해 리팩토링 하면 다음과 같다.

```

abstract class 강아지 {
  abstract void 소변보다()
}

class 수컷강아지 extends 강아지 {
  void 소변보다() {
    // ...
  }
}

class 암컷강아지 extends 강아지 {
  void 소변보다() {
    // ...
  }
}

```
  
  
## OCP - 개방 폐쇄 원칙
소프트웨어 엔티티(클래스, 모듈, 함수 등)은 확장에 대해서는 열려 있어야 하지만, 변경에 대해서는 닫혀 있어야 한다. - 로버트 C.마틴

운전자가 수동 조작 차량을 보유하고 있었는데, 이후 자동 조작 차량으로 차량을 변경하게 되었다.   
현실 세계에서라면 습관에 변화가 생기는게 불가피하지만 객체 지향 세계에서는 이를 방지할 수 있다.

+ 아래와 같이 코드를 작성하면 수동 조작 차량을 보유했을 때와 자동 조작 차량을 보유했을 때 일일이 메서드를 변경해야 한다.
```

class 마티즈 {
  void 수동 기어 조작() {
    ...
  }
}

마티즈 운전자 = new 마티즈();

// 또는

class 쏘나타 {
  void 자동 기어 조작() {
    ...
  }
}

쏘나타 운전자 = new 쏘나타();

``` 
  
+ 위 코드를 리팩토링하여 작성하면 다음과 같다.

```

interface 자동차 {
  abstract void 창문개방();
  abstract void 기어조작();
}

class 마티즈 implements 자동차 {
  void 창문개방() {
    ...
  }
  
  void 기어조작() {
    ...
  }
}

class 쏘나타 implements 자동차 {
  void 창문개방() {
    ...
  }
  
  void 기어조작() {
    ...
  }
}

자동차 운전자 = new 마티즈();
자동차 운전자 = new 쏘나타();

```
  
  
## LSP - 리스코프 치환 원칙
서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.  - 로버트 C.마틴

+ 객체 지향의 상속은 다음 조건을 만족해야 한다.
  - 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류이다.
  - 구현 클래스 is able to 상위 인터페이스 - 구현 분류는 인터페이스 할 수 있어야 한다.
  - 하위형에서 선행 조건은 강화될 수 없다.
  - 하위형에서 후행 조건은 약화될 수 없다.
  - 하위형에서 상위형의 불변 조건은 반드시 유지되어야 한다.
  
+ 잘못된 상속의 예

```
아버지 춘향이 = new 딸();
```
딸을 한 명 낳아 이름을 춘향이라고 지었으며 춘향이는 아버지의 역할을 한다 ?
위 상속대로라면 춘향이가 아버지의 역할을 해야 하는데 이는 리스코프 치환 원칙을 위배하는 것이다. (계층도/조직도)

+ 올바른 상속의 예


```
동물 뽀로로 = new 펭귄();
```

펭귄 한 마리가 태어나 뽀로로라고 이름지었으며, 뽀로로는 동물의 역할을 한다. 
위 상속은 리스코프 치환 원칙을 만족한다. (분류도)


## ISP - 인터페이스 분리 원칙
클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.  - 로버트 C.마틴

예를 들어 남자 클래스에 기념일챙기기, 효도하기, 출근하기, 사격하기 등 다양한 메서드가 존재한다면 이는 단일 책임 원칙을 위배하는 것이다.
이를 해결하기 위해 메서드를 각각 인터페이스로 분할하여 역할을 제한하는 것이 ISP의 핵심이다.


## DIP - 의존 역전의 원칙
고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.   
추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.   
자주 변경되는 구체(concrete) 클래스에 의존하지 마라. - 로버트 C.마틴




