# SOLID
객체지향 설계(OOD)의 5원칙

+ SRP (단일 책임 원칙)
+ OCP (개방 폐쇄 원칙)
+ LSP (리스코프 치환 법칙)
+ ISP (인터페이스 분리 법칙)
+ DIP (의존 역전 법칙)

+ 좋은 소프트웨어 설계를 위해 결합도는 낮추고 응집도는 높이는 것이 바람직함.
  - 결합도 : 모듈(클래스) 간의 상호 의존 정도   
    결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객채의 재사용이나 수정, 유지보수가 용이함
  + 응집도 : 하나의 모듈 내부에 존재하는 구송 요소들의 기능적 관련성   
    응집도가 높을수록 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이함



## SRP - 단일 책임 원칙
  어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. - 로버트 C. 마틴

+ 속성이 SRP 원칙을 위배한 경우
  + 서브 클래스 전체에 공통적으로 필요하지 않는 속성을 슈퍼 클래스 속성에 작성한 경우   
  + 하나의 속성이 여러 의미를 갖는 경우

```

class 사람 {
  String 군번;
  String 이름;
  ...
}

사람 로미오 = new 사람();
사람 줄리엣 = new 사람();

줄리엣.군번 = "12354"; // ?

```
남성만 군번 속성을 가질 수 있도록 코드를 작성하고 싶었으나,   
위와 같이 코드를 작성하면 여성이 군번 속성을 읽어오거나 값을 할당하는것을 제제할 방법이 없다.   
위 소스를 리팩토링하면 다음과 같다.


```

class 사람 {
  String 이름;
  ...
}

class 남성 extends 사람 {
  String 군번;
}

class 여성 extends 사람 {
  ...
}

사람 로미오 = new 남성();
사람 줄리엣 = new 여성();

줄리엣.군번 = "12354"; // 군번 속성을 읽어오거나 값을 할당할 수 없다.

```


+ 메서드가 SRP 원칙을 위배한 경우
  + 소변보다() 메서드가 수컷과 암컷의 행위 모두를 구현하려고 하기 때문에 SRP 원칙을 위배한다.
  + 메서드가 SRP 원칙을 위배할 때 나타나는 대표적인 경우가 분기처리를 위한 if문이다.

```

class 강아지 {
  final static Boolean 수컷 = true;
  final static Boolean 암컷 = false;
  Boolean 성별;
  
  void 소변보다() {
    if(this.성별 == 수컷) {
      // ...
    } else {
      // ...
    }
  }
}

```
    
위 메서드를 SRP 원칙을 적용해 리팩토링 하면 다음과 같다.

```

abstract class 강아지 {
  abstract void 소변보다()
}

class 수컷강아지 extends 강아지 {
  void 소변보다() {
    // ...
  }
}

class 암컷강아지 extends 강아지 {
  void 소변보다() {
    // ...
  }
}

```
  
  
  
  
  
  
  
  
