# 디자인 패턴
이전의 많은 개발자들이 고민하고 정제한 표준 설계 패턴

- 디자인 패턴의 방식?
  - 상속 (extends)
  - 인터페이스 (interface / implements)
  - 합성 (객체를 속성으로 사용)
  
- 어댑터 패턴 (Adapter Pattern)
  - 변환기, 즉 서로 다른 두 인터페이스 사이에 통신이 가능케 하는 것
  - 호출당하는 쪽의 메서드를 호충하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴
  
- 프록시 패턴 (Proxy Pattern)
  - 프록시 = 대리자, 대변인
  - 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴
  - 대리자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다
  - 대리자는 실제 서비스에 대한 참조 변수를 갖는다 (합성)
  - 대리자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 돌려준다
  - 대리자는 실제 서비스의 메서드 호출 전후에 별도로 로직을 수행할 수도 있다
  - 특별한 경우가 아니면 반환값을 변경하지 않음
  
- 데코레이터 패턴 (Decorator Pattern)
  - 프록시 패턴과 구현 방법이 같으나, 최종적으로 돌려 받는 반환값에 장식을 덧입힌다
  - 메서드 호출의 반환값에 변화를 주기 위해 중간에 장식자를 두는 패턴
  
- 싱글턴 패턴 (Singleton Pattern)
  - 인스턴스를 하나만 만들어 사용하기 위한 패턴으로, 인스턴스를 재사용함
  - new를 실행할 수 없도록 생성자에 private 접근 제어자를 지정함
  - 유일한 단일 객체를 반환할 수 있는 정적 메소드가 필요함
  - 유일한 단일 객체를 참조할 정적 참조 변수가 필요함
  - 단일 객체는 쓰기 가능한 속성을 갖지 않는 것이 정석이다
  
```

public class Singleton {
  static Singleton singletonObject; // 정적 참조 변수
  
  private Singleton() { }; // private 생성자
  
  // 객체 반환 정적 메서드
  // 객체가 null이면 새로 생성하고, 이미 존재하면 이미 생성한 객체를 리턴한다
  public static Singleton getInstance() {
    if (singletonObject == null) {
      singletonObject = new Singleton();
    }
    
    return singletonObject;
  }
}

```
